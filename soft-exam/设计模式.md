## 设计模式

> 针对某类问题的解决方案，复用成功的设计
>
> 模式名称 + 问题 + 解决方案 + 效果

### 创建型设计模式

#### 简单工厂模式

> 工厂类有一个创建方法，能够根据不同参数返回不同的对象实例。
>
> 存在的问题：如果需要增加新的功能，需要修改工厂类的内部代码，违反了开闭原则【软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的】。

#### 工厂方法模式【类】

> 工厂方法模式
> 每个工厂只负责单一产品类的创建，工厂的数量翻倍但是进行扩展时只需要增加一个产品类，一个工厂类即可

- 定义一个用于创建对象（工厂）的接口，让子类决定实例化哪个类。使一个类的实例化延迟到子类。

```java
interface Product {
  public void info ();
}

class ProductA implements Product {
  @Override
  public void info () {
    System.out.println("product A");
  }
}

class ProductB implements Product {
  @Override
  public void info () {
    System.out.println("product B");
  }
}

interface Factory {
  public Product createProduct ();
}

class FactoryA implements Factory {
  @Override
  public Product createProduct () {
    return new ProductA();
  }
}

class FactoryB implements Factory {
  @Override
  public Product createProduct () {
    return new ProductB();
  }
}
```

#### 抽象工厂模式

>     在工厂方法模式基础上进行归类
> 一个工厂不只是生成一个产品类，但是相同工厂生产的产品类具有相同的特征或者偏好
> 1.例如现在要两个类，数据库执行、数据库查询。两个类型oracle、mysql都实现这两个步骤，一共4个类。
> 2.声明2个工厂，oracle、mysql工厂。
> 3.每个工厂具有自己类型的执行、查询方法，即实例化1步骤中的类

#### 生成器模式（Builder）

> 生成器Builder定义每个组件如何生成，并能返回需要构建的对象
> 导演Director，通过在方法中传入生成器，调用生成器的组件生成方法，完成后并获得构建的对象

- 意图：将复杂对象的构件与它的表示分离，使得同样的构件过程可以创建不同的表示。

#### 原型模式

> 原型模式，另一种实例化的方法，通过克隆已经实例化的对象完成。适用于构造函数耗时，避免重复执行构造函数；适用于对实例化后对象能够进行属性更改，需构造相同的对象。
>
> Prototype声明复制自身的接口
>
> ConcretePrototype实现复制自身操作
>
> Client调用复制

- 用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象

#### 单例模式

- 保证一个类仅有一个实例，并提供一个访问它的全局访问点
- 构造方法声明为private，保证外部无法进行构建

### 结构型设计模式

#### 适配器模式【类】

> 新增一个适配目标类(adapter)
> 实现适配目标类，接收适配前实例(adaptee)，声明方法，内部调用适配前实例(adaptee)的方法。

- 将一个类的接口转换成客户希望的另外一个接口。

#### 桥接模式

> 需要根据情况进行多重继承的情况，每一重都有多个选择。
> 桥接模式通过将原本需要继承的类的实例作为参数传入构造函数，调用实例的方法即可。
> 将复杂系统中的稳定部分与易变部分解耦。通过组合优于继承的原则，构建弹性架构

- 将抽象与其实现部分分离，使他们都可以独立地变化

#### 组合模式

> 组合模式用于处理树形结构问题。
>
> 叶子节点类和非叶子节点类都从同一接口实现。

- 将对象组合成树形结构以表示“部分-整体”的层次结构，Composite使得用户对单个对象和组合对象的使用具有一致性。

#### 装饰模式

> 装饰器模式：通过一个新类，传入已有的实例，在调用原对象方法前后添加新逻辑，从而达到扩展原有实例的目的

- 动态的给一个对象添加一些额外的指责。

#### 外观模式

> 将某些子系统的操作封装到一个类中，客户端调用这个类的一个方法达到集成一系列操作的目的

- 为子系统的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一系统更加容易使用。

#### 享元模式

> 分为外部状态和内部状态，外部为共享的数据
>
> 通过Map进行储存，返回已经创建的数据

- 运用共享技术有限地支持大量细粒度的对象
- 适用于
  - 应用程序使用了大量对象，因此造成大量储存开销
  - 对象的大多数状态可变为外部状态

#### 代理模式

> 代理模式：通过一个新代理类，传入已有的被代理实例，重写原对象方法，从而达到代理目的。
> 和装饰者模式有些像，目的不同。装饰者模式为了增加功能；代理模式为了控制访问。
> 装饰者模式因为可能存在很多具体装饰者，所以抽离了一个abstract Class，而代理模式只是一对一的代理，其实具体实现很相像。但是单一装饰者也可以不抽离abstract class

- 为其他对象提供一种代理以控制对这个对象的访问

### 行为型设计模式

#### 责任链模式

- 使多个对象都有机会处理请求，将对象连成一条链，沿着这条链传递请求，知道有一个对象处理它为止。

#### 命令模式

> 抽象命令：能下发哪些命令
> 具体命令：实现抽象命令的具体方法，主体通过构造函数传入
> 调用者：声明新的方法，内部去调用具体命令的方法。具体命令通过构造函数传入
>
> 将调用者和执行者拆分，通过命令连接起来

- 将一个请求封装为一个对象，从而使得可以用不同的请求对客户进行参数化。
- 适合的情况
  - 抽象出待执行的动作以参数化某对象
  - 在不同的时刻指定，排列和执行请求
  - 支持取消操作
  - 支持修改日志
  - 用构建在原语操作上的高层操作构建一个系统。

#### 解释器模式【类】

- 定义一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
- 适用于当有一个语言需要解释执行，并可将该语言中的句子表示为一个抽象语法树时。

#### 迭代器模式

> interface Iterator { next() hasNext(); }
> 迭代器去实现这两个方法，保证对于客户端来说使用的时候能够通过next()按照预期进行数据的依次访问。
> 迭代器实现对某类数据结构进行按照预期的访问，不同的迭代器能够对相同的数据产生不同的访问方式。

- 提供一种顺序访问一个聚合对象中的各个元素

#### 中介者模式

> 中介者模式
> 核心目标是解耦对象间的直接依赖关系。通过引入一个中介对象来统一管理多个对象间的交互，使得对象间不再直接通信，而是通过中介者进行协调。
> 中介者 发送消息 添加对象
> 对象 对应中介者 接收消息
> 中介者和对象之间互相有储存对应关系
>
> 发送流程：
> 发送消息时，对象定义方法 调用中介者的发送消息方法进行消息发送；
> 中介者处理消息（业务流程）；
> 中介者通过遍历对象，通过对象的接收消息方法传递消息

- 用中介对象来封装一系列的对象交互，中介者使各个对象不需要显式地相互引用。
- 适用于
  - 一组对象以定义良好但是复杂的方式进行通讯，产生的相互依赖关系结构混乱且难以理解。
  - 一个对象引用其他很多对象并且与这些对象通信，从而使其耦合松散
  - 定制一个分布在多个类中的行为，而又不想生成太多的子类

#### 备忘录模式

> Memento（备忘录）类的作用是 利用内部变量（private）去储存一次状态
> Caretaker（管理者）的作用是 利用栈储存每次的状态
> 新增记录时，实例化Memento，添加到Caretaker中
> 回退时，在Caretaker中推出数据，并作为当前数据
> Originator（发起人）创建Memento储存状态，恢复状态

- 在不破坏封装性的前提下捕获一个对象的内部状态，在对象之外保存这个状态，以后可以将对象恢复到原先保存的状态。
- 适用于
  - 必须保存一个对象在某个时刻的状态，便于恢复到先前状态
  - 如果一个接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性

#### 观察者模式

> 观察者 订阅 主题
> 主题 接口：添加/删除订阅者；向观察者发布消息
> 观察者 提供一个方法，用于主题发布消息时调
> 推模型是将消息发送到observer，而拉模型是将subjet传递给observer，由observer自己调用subject方法去拿数据

- 定义对象间的一对多依赖关系，当一个对象状态变化时，所有依赖于它的对象都得到通知并被自动更新
- 适用于
  - 一个抽象模型有两方面，一个方面依赖于另一方面，将这两者封装在独立的对象中使他们可以各自独立地改变和复用。
  - 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时
  - 一个对象必须通知其他对象，又不能假定其他对象是谁，即不希望这些对象是紧耦合的

#### 状态模式

> 状态与行为的解耦
>
> `ins.doxx -> state.handle(this) -> ins.setState(state) and do something`
>
> 将状态统一封装，状态的变更放到state里，state自动转换+处理对应逻辑

- 允许一个对象在其内部状态改变时改变他的行为。
- 适用于
  - 一个对象的行为取决于它的状态，它必须在运行时刻根据状态改变他的行为
  - 一个操作中含有庞大的多分支条件语句，且这些分支依赖于该对象的状态

#### 策略模式

> 策略模式将流程式的判断变成了内存中储存各个策略，运行时判定取哪个策略再拿出来执行，从而达到了策略和业务逻辑分离的目的。
> 策略接口-->策略类。策略类定义了相同名的算法。
> 上下文类，储存策略类的实例化并提供方法进行执行。
> 客户端，获取策略类，实例化后传入上下文，调用上下文方法从而执行策略的方法。运行时可动态切换策略实例达到更换的目的
>
> 如果策略多可以再使用工厂模式 生产策略类

- 定义一系列算法，将他们一个个封装起来，并且使他们可以相互替换。
- 适用于
  - 许多相关的类仅仅是行为有异
  - 当需要使用一个算法的不同变体
  - 算法使用客户不应该知道的数据
  - 一个类定义了多种行为

#### 模版方法【类】

> 模板模式 通过抽象类将总体流程方法 及 部分固有方法实现好，将总体流程方法定义为final不可变，需要调整的方法写为抽象abstract，等待子类来具体实现。还可通过重写hook方法（预定义好，可不重写）来修改父类固有方法的逻辑分支。

- 定义一个操作中的算法骨架，而将一些步骤延迟到子类中。`Template Method`使得子类可以不改变一个算法的结构即可重定义该算法的特定步骤
- 适用于
  - 一次性实现一个算法的不变部分，将可变行为留给子类来实现
  - 各子类公共的行为应被提取出来并集中到一个公共父类中，以免代码重复
  - 控制子类扩展，只允许在特定点进行扩展。

#### 访问者模式

>
> 访问者模式是一种行为型设计模式，核心在于将数据操作与数据结构分离。它允许在不修改已有对象结构的前提下，为对象结构中的元素添加新操作。
> Visitor决定了怎么去看一个Document
> document.accept(visitor) = visitor.visit(document)
> 这样处理保证了是文档本身发起预览操作
> document具有 增加、发起预览文档的功能。visitor只实现预览方式。

- 表示一个作用于某对象结构中的各元素的操作。在不改变各元素的类的前提下，定义作用于这些元素的新操作。

- 适用于

  - 一个对象结构包含很多类对象，他们有不同的接口
  - 需要对一个对象结构中的对象进行很多不同且不相关的操作。
  - 定义对象结构的类很少改变，但经常需要在此结构上定义新的操作

  