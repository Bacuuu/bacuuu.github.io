## 设计模式

> 针对某类问题的解决方案，复用成功的设计
>
> 模式名称 + 问题 + 解决方案 + 效果

**创建型设计模式**

### 简单工厂模式

> 工厂类有一个创建方法，能够根据不同参数返回不同的对象实例。
>
> 存在的问题：如果需要增加新的功能，需要修改工厂类的内部代码，违反了开闭原则【软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的】。

### 工厂方法模式

> 工厂方法模式
> 每个工厂只负责单一产品类的创建，工厂的数量翻倍但是进行扩展时只需要增加一个产品类，一个工厂类即可

- 定义一个用于创建对象（工厂）的接口，让子类决定实例化哪个类。使一个类的实例化延迟到子类。

```java
interface Product {
  public void info ();
}

class ProductA implements Product {
  @Override
  public void info () {
    System.out.println("product A");
  }
}

class ProductB implements Product {
  @Override
  public void info () {
    System.out.println("product B");
  }
}

interface Factory {
  public Product createProduct ();
}

class FactoryA implements Factory {
  @Override
  public Product createProduct () {
    return new ProductA();
  }
}

class FactoryB implements Factory {
  @Override
  public Product createProduct () {
    return new ProductB();
  }
}
```

### 抽象工厂模式

>     在工厂方法模式基础上进行归类
> 一个工厂不只是生成一个产品类，但是相同工厂生产的产品类具有相同的特征或者偏好
> 1.例如现在要两个类，数据库执行、数据库查询。两个类型oracle、mysql都实现这两个步骤，一共4个类。
> 2.声明2个工厂，oracle、mysql工厂。
> 3.每个工厂具有自己类型的执行、查询方法，即实例化1步骤中的类

### 生成器模式（Builder）

> 生成器Builder定义每个组件如何生成，并能返回需要构建的对象
> 导演Director，通过在方法中传入生成器，调用生成器的组件生成方法，完成后并获得构建的对象

- 意图：将复杂对象的构件与它的表示分离，使得同样的构件过程可以创建不同的表示。

### 原型模式

> 原型模式，另一种实例化的方法，通过克隆已经实例化的对象完成。适用于构造函数耗时，避免重复执行构造函数；适用于对实例化后对象能够进行属性更改，需构造相同的对象。
>
> Prototype声明复制自身的接口
>
> ConcretePrototype实现复制自身操作
>
> Client调用复制

- 用原型实例指定创建对象的种类，并通过复制这些原型创建新的对象

### 单例模式

- 保证一个类仅有一个实例，并提供一个访问它的全局访问点
- 构造方法声明为private，保证外部无法进行构建

**结构型设计模式**

### 适配器模式

> 新增一个适配目标类(adapter)
> 实现适配目标类，接收适配前实例(adaptee)，声明方法，内部调用适配前实例(adaptee)的方法。

- 将一个类的接口转换成客户希望的另外一个接口。

### 桥接模式

> 需要根据情况进行多重继承的情况，每一重都有多个选择。
> 桥接模式通过将原本需要继承的类的实例作为参数传入构造函数，调用实例的方法即可。
> 将复杂系统中的稳定部分与易变部分解耦。通过组合优于继承的原则，构建弹性架构

- 将抽象与其实现部分分离，使他们都可以独立地变化

### 组合模式

> 组合模式用于处理树形结构问题。
>
> 叶子节点类和非叶子节点类都从同一接口实现。

- 将对象组合成树形结构以表示“部分-整体”的层次结构，Composite使得用户对单个对象和组合对象的使用具有一致性。

### 装饰模式

> 装饰器模式：通过一个新类，传入已有的实例，在调用原对象方法前后添加新逻辑，从而达到扩展原有实例的目的

- 动态的给一个对象添加一些额外的指责。

### 外观模式

> 将某些子系统的操作封装到一个类中，客户端调用这个类的一个方法达到集成一系列操作的目的

- 为子系统的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一系统更加容易使用。

### 享元模式

> 分为外部状态和内部状态，外部为共享的数据
>
> 通过Map进行储存，返回已经创建的数据

- 运用共享技术有限地支持大量细粒度的对象
- 适用于
  - 应用程序使用了大量对象，因此造成大量储存开销
  - 对象的大多数状态可变为外部状态

### 代理模式

> 代理模式：通过一个新代理类，传入已有的被代理实例，重写原对象方法，从而达到代理目的。
> 和装饰者模式有些像，目的不同。装饰者模式为了增加功能；代理模式为了控制访问。
> 装饰者模式因为可能存在很多具体装饰者，所以抽离了一个abstract Class，而代理模式只是一对一的代理，其实具体实现很相像。但是单一装饰者也可以不抽离abstract class

- 为其他对象提供一种代理以控制对这个对象的访问

