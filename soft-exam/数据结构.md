## 数据结构

### 复杂度

#### 大O表示法

![image-20250423195127654](./assets/image-20250423195127654.png)

#### 时间复杂度

算法执行时间随输入规模增长而变化的度量

#### 空间复杂度

空间随输入规模增长而变化的度量（输入数据不算空间）

#### 渐进符号（看不懂，后面再看）

> 分为三个界~~（这不华为么）~~
>
> 上界`O` 下界`Ω` 紧致界`θ`
>
> 例如，判断10n^2 + 4n + 2 = O(n^2)是否成立
>
> 则上界的括号里面需要大于等于表达式的复杂度
>
> 下界 需要 小于等于
>
> 紧致界 需要 等于

#### 递归时间、空间复杂度

- 时间复杂度：递归的次数 * 每次递归的时间复杂度

- 主观法（从[Spike8086](https://www.bilibili.com/video/BV15T411p7ja/?share_source=copy_web&vd_source=da06af369eda2d9e301dfbead2f13295)处学习）：

  ![image-20250423203025424](./assets/image-20250423203025424.png)

  这里的T(n/b)是和T(n)类似的函数！！

  常见题目是

  1. 计算空间复杂度。
     1. 符合上面公式的直接套。
     2. n^k对不上而且有㏒<sup>k</sup>n的，直接选有㏒<sup>k+1</sup>n的
  2. 两个算法比速度，求算式中某个值的最大值。
     1. 套到公式里，使得两个的值尽量靠近

### 线性结构

#### 线性表

- 顺序储存 ｜ 链式储存

**顺序存储**

- 使用地址连续的储存单元依次存储线性表
- 插入：先移动元素、再加入添加的元素。
  - 长度为n，期望为`n / 2`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均（同上面期望）：`O(n)`
- 删除：先删除元素，再移动剩余元素。 
  - 长度为n，期望为`(n - 1) / 2`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均（同上面期望）：`O(n)`
- 查找：`O(1)`

**链式存储**

- 通过指针链接起来的结点来存储数据元素。`[数据域, 指针域]`
- 插入：新`node.next`指向`prev.next`，`prev.next`再指向`node`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均：`O(n)`
- 删除：`prev.next`指向`prev.next.next`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均：`O(n)`
- 查找：循环查找`next`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均：`O(n)`

**循环单链表**

- 可以从任何一个结点开始，遍历完整个数据结构。
- 尾结点：表的最后一个结点，尾部插入时可以直接用尾结点进行操作。

**双链表**

- `[数据域, 指针域（前、后）]`

#### 栈

- 只能访问数据结构的一端，先进后出、后进先出
- 栈的链式存储，只需要设置栈顶指针。入栈、出栈都不需要遍历链表。
- 常用于实现函数或过程的递归调用及返回处理时
- **做题时切记，给的元素可以单个进了就出，不是非要所有一起进！！**

#### 队列

- 先进先出的线性表，**插入端称为队尾，删除端称为队头**。
- 插入、删除后，之前的空间无法再利用，所以出现了循环队列，**尾指针是在最后的元素后面一个位置**。

<img src="./assets/image-20250426092826463.png" alt="image-20250426092826463" style="zoom:33%;" />

- 队列链式存储（队头、队尾指针）
- 双端队列：两端都可以入或出（根据题目来定）

📒 从题中的总结

- 采用循环队列的优点是：入队出队操作都不需要移动队列中其他元素。（静态队列需要移动，避免之前用过的空间无法再使用）
- 两个栈可以模拟一个队列

#### 串



