## 数据结构

### 复杂度

#### 大O表示法

![image-20250423195127654](./assets/image-20250423195127654.png)

#### 时间复杂度

算法执行时间随输入规模增长而变化的度量

#### 空间复杂度

空间随输入规模增长而变化的度量（输入数据不算空间）

#### 渐进符号（看不懂，后面再看）

> 分为三个界~~（这不华为么）~~
>
> 上界`O` 下界`Ω` 紧致界`θ`
>
> 例如，判断10n^2 + 4n + 2 = O(n^2)是否成立
>
> 则上界的括号里面需要大于等于表达式的复杂度
>
> 下界 需要 小于等于
>
> 紧致界 需要 等于

#### 递归时间、空间复杂度

- 时间复杂度：递归的次数 * 每次递归的时间复杂度

- 主观法（从[Spike8086](https://www.bilibili.com/video/BV15T411p7ja/?share_source=copy_web&vd_source=da06af369eda2d9e301dfbead2f13295)处学习）：

  ![image-20250423203025424](./assets/image-20250423203025424.png)

  这里的T(n/b)是和T(n)类似的函数！！

  常见题目是

  1. 计算空间复杂度。
     1. 符合上面公式的直接套。
     2. n^k对不上而且有㏒<sup>k</sup>n的，直接选有㏒<sup>k+1</sup>n的
  2. 两个算法比速度，求算式中某个值的最大值。
     1. 套到公式里，使得两个的值尽量靠近

### 线性结构

#### 线性表

- 顺序储存 ｜ 链式储存

**顺序存储**

- 使用地址连续的储存单元依次存储线性表
- 插入：先移动元素、再加入添加的元素。
  - 长度为n，期望为`n / 2`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均（同上面期望）：`O(n)`
- 删除：先删除元素，再移动剩余元素。 
  - 长度为n，期望为`(n - 1) / 2`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均（同上面期望）：`O(n)`
- 查找：`O(1)`

**链式存储**

- 通过指针链接起来的结点来存储数据元素。`[数据域, 指针域]`
- 插入：新`node.next`指向`prev.next`，`prev.next`再指向`node`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均：`O(n)`
- 删除：`prev.next`指向`prev.next.next`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均：`O(n)`
- 查找：循环查找`next`
  - 最好：`O(1)`
  - 最坏：`O(n)`
  - 平均：`O(n)`

**循环单链表**

- 可以从任何一个结点开始，遍历完整个数据结构。
- 尾结点：表的最后一个结点，尾部插入时可以直接用尾结点进行操作。

**双链表**

- `[数据域, 指针域（前、后）]`

#### 栈

- 只能访问数据结构的一端，先进后出、后进先出
- 栈的链式存储，只需要设置栈顶指针。入栈、出栈都不需要遍历链表。
- 常用于实现函数或过程的递归调用及返回处理时
- **做题时切记，给的元素可以单个进了就出，不是非要所有一起进！！**

#### 队列

- 先进先出的线性表，**插入端称为队尾，删除端称为队头**。
- 插入、删除后，之前的空间无法再利用，所以出现了循环队列，**尾指针是在最后的元素后面一个位置**。

<img src="./assets/image-20250426092826463.png" alt="image-20250426092826463" style="zoom:33%;" />

- 队列链式存储（队头、队尾指针）
- 双端队列：两端都可以入或出（根据题目来定）

📒 从题中的总结

- 采用循环队列的优点是：入队出队操作都不需要移动队列中其他元素。（静态队列需要移动，避免之前用过的空间无法再使用）
- 两个栈可以模拟一个队列

#### 串

- 是特殊的线性表，仅由字符构成的有限序列。

**串的模式匹配**

- **模式串m**去**主串n**中进行匹配
- 朴素模式：一个一个去对比，去暴力对比。
  - 复杂度最好：`O(m)`
  - 最坏：`m * (n - m + 1) = O(n * m)`
  - 平均：`O(n + m)`
- `KMP`
  - 串的前缀：包含第一个字符且不含最后一个字符的子串
  - 串的后缀：包含最后一个字符且不含第一个字符的子串
  - 第`i`个字符的`next`值：从`1`到`i - 1`串中**最长相等前后缀**长度 + 1。其中，`next[1] = 0`
  - `KMP`算法
    - 主串`i`，模式串`j`，对比时`i`不回退
    - 当不匹配时，`j`回到`next`值，并和`i`进行比较

#### 数组

- 二维数组：`a[行号][列号]`

- 行存储：优先铺满行；列存储：优先铺满列

  ![image-20250427205149278](./assets/image-20250427205149278.png)

#### 矩阵（题目进行带入验证）

- 对称矩阵
  - 储存下三角区 + 对角线元素。
  - `a[i, j] = a[j, i]`
- 三对角矩阵
  - 主对角线附近的元素有值
- 稀疏矩阵
  - 非常多的0元素，将其储存为一维数组，每个元素包含`[行号, 列号, 值]`
  - 压缩存储方式为 **三元组顺序表** 和 **十字链表**

#### 树

- 非线性结构，一个数据元素可有0个或多个直接后继元素
- 概念：
  - 双亲：父结点
  - 结点的度：结点的**子树个数**
  - 叶子结点：度为0的结点
  - 内部结点：度不为0的结点
  - 结点的层次：字面意思。
  - 树的高度：一个树的最大层树为树的高度
- 性质：
  - 树中结点总数等于所有结点的度数之和加一（根结点）
  - 度为m的树中，第i层最多有m<sup>i-1</sup>个结点
  - 高度为h的m次树（度为m），最多有`(m ^ h - 1) / (m-1)`个结点
  - 具有n个结点，度为m的树的最小高度为`logm(n*(m-1) + 1)`

#### 二叉树

- 二叉树中结点的子树要区分左、右子树，即使只有一棵子树，也要指明是左还是右。
- 性质（大部分由上面树的性质推出）：
  - 对于任意一棵二叉树，度为0的结点数等于度为2的结点数+1
- 满二叉树：深度为k的二叉树有2<sup>k</sup>-1个结点。**有n层，则除了第n层全是度为2的结点，最满的情况！！**
- 完全二叉树：在满二叉树的基础上，最后一层可不满，但是都是从左往右排列。
  - 具有n个结点的完全二叉树的高度为Math.floor(log<sub>2</sub>n) + 1或Math.ceil(log<sub>2</sub>(n+1))

##### 存储结构

- 顺序存储（做题现画现推）

  - 中序遍历后依次存入，空结点也要存入。
  - 最坏情况下深度为`k`且只有`k`个结点的二叉树，需要2<sup>k</sup>-1个存储单元

- 链式存储

  - 二叉链表储存左右子结点的指针

  ![image-20250506193415289](./assets/image-20250506193415289.png)

📒 从题中的总结

- 完全二叉树更适合顺序存储，空结点少，利用率高
- 计算链表存储二叉树时，空指针记得计算根结点！！

##### 二叉树的遍历

- 先序遍历：**根** ➡️ 左 ➡️ 右
- 中序遍历：左 ➡️ **根** ➡️ 右
- 后序遍历：左 ➡️ 右 ➡️ **根**
- 层序遍历：从上往下，从左到右遍历
- **给出序列（一定有中序），反向构建二叉树**：
  - 先序：可以立刻确定第一个为根结点
  - 后序：可以立刻确定最后一个为根结点
  - 层序：第一个为根结点
  - 根据先、后去确定根结点，分左右后再次确定下面的根结点

##### 平衡二叉树

- 二叉树中任意一个结点的左右子树高度之差绝对值不超过1

##### 二叉排序树（左边小，右边大）

- 结点的值 大于左子树所有结点的值；小区右子树所有结点的值。
- 通过中序遍历得到的序列是有序序列
- 二叉排序树的构造：依次比较，小则作为左树，大则作为右树
- **效率最差**的二叉查找树是：单只树
- **从左到右排列同层次**的结点，其关键字呈现有序排列的特点

##### 最优二叉树（哈夫曼树）

- 加权路径长度最短的树。加权：`结点的值 * 到结点的路径`

- **构造哈夫曼树（给出权值）**：以**1 3 3 4**为例

  - 选出最小的两个值（1、3），以这两个作为子结点
  - 生成父结点，值为1+3=4，现在权值为 **4 3 4**
  - 同上，再选（4、3）作为子结点
  - 生成父结点4+3=7，现在权值为 **7 4**

  <img src="./assets/image-20250506202557463.png" alt="image-20250506202557463" style="zoom:50%;" />

- 构造规则：

  - 从前往后找权值最小
  - 小左大右
  - 相加后加入末尾
  - 权值相同，从前往后找

- 哈夫曼编码：先编码，再组树，再通过路径编码

<img src="./assets/image-20250506205210233.png" alt="image-20250506205210233" style="zoom:50%;" />

- 哈夫曼编码压缩比
  - 先算等长编码：2^n >= 字符数
  - （等长 - 压缩） / 等长

📒 从题中的总结

- 哈夫曼编码方案基于 **贪心策略**
- 哈夫曼权重越大离根越近，权重越小离根越远

##### 线索二叉树

